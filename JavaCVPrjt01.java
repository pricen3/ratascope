package motion_tracking;

import static java.nio.file.StandardWatchEventKinds.*;
import java.awt.image.BufferedImage;
import java.awt.*;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.MatOfByte;
import org.opencv.core.MatOfPoint;
import org.opencv.core.Rect;
import org.opencv.core.Scalar;
import org.opencv.core.Size;
import org.opencv.highgui.Highgui;
import org.opencv.highgui.VideoCapture;
import org.opencv.imgproc.Imgproc;
import org.opencv.video.BackgroundSubtractorMOG2;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

public class JavaCVPrjt01 {
  static {
    System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
  }

  static Mat imag = new Mat();
  static Mat imag2 = new Mat();

  public static void main(String[] args) {
    err = false;
    WatchEvent queued;
    WatchService queueWatch = FileSystems.getDefault().newWatchService();
    Path queueDir = Paths.get("/CAMPR/queue");
    WatchKey queueKey = queueDir.register(queueWatch, ENTRY_CREATE, ENTRY_MODIFY);
    while(!err) {
      WatchKey queueKey = queueWatch.poll();
      List<WatchEvent<?>> files = queueKey.pollEvents();
      if (queued=files.get(0)) {
        T filename = queued.context();
        //System.out.println("Starting program");
        JFrame jframe = new JFrame("Circardian and Movement Phenotype Recorder (CAMPR)");
        jframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        JLabel vidpanel = new JLabel();
        jframe.setContentPane(vidpanel);
        jframe.setPreferredSize(new Dimension(960, 720));
        jframe.setMinimumSize(new Dimension(960, 720));
        jframe.pack();
        jframe.setVisible(true);
        jframe.setState(Frame.ICONIFIED);
        jframe.setState(Frame.NORMAL);

        Mat frame = new Mat();
        VideoCapture camera = new VideoCapture();
        if (camera.open("C:/Users/e6440/Downloads/mouse_vid3.mp4")) {
          System.out.println("File opened succesfully.");
        } else {
          System.out.println("Cannot open file.");
          System.exit(0);
        }

        Size sz = new Size(960, 720);
        Mat fgMaskMOG2 = new Mat(); //fg mask fg mask generated by MOG2 method
        BackgroundSubtractorMOG2 mog2 = new BackgroundSubtractorMOG2(200, 50f, true);
        Mat imgH = new Mat();
        double startTime = System.nanoTime();
        double maxArea = 0;
        double prevArea = 0;

        BufferedWriter bw = null;
        File file = new File("C:/Users/e6440/Downloads/sample.txt");
        try {
          FileWriter fw = new FileWriter(file);
          bw = new BufferedWriter(fw);
        } catch (Exception e) {
          System.out.println(e);
        }

        int toply = 0;
        int toplx = 0;

        while (camera.read(frame)) {
          //System.out.println("Reading frames succesfully.");
          Imgproc.resize(frame, frame, sz);
          imgH = frame.clone();
          Imgproc.cvtColor(imgH, imgH, Imgproc.COLOR_RGB2GRAY);
          Imgproc.GaussianBlur(imgH, imgH, new Size(17, 17), 0);
          imgH.convertTo(imgH, -1, 1, 1);
          mog2.apply(imgH, fgMaskMOG2, 0.0009);

          double endTime = System.nanoTime();
          double totalTime = (endTime - startTime) / (1000000000);

          Rect r = detect_mouse(fgMaskMOG2);
          if (r != null) {
          if (toplx == 0) {
          toplx = (int) r.tl().x;
          toply = (int) r.tl().y;
          } else {
          if ((r.tl().x > (toplx-30)) && (r.tl().x < (toplx+30))) {
          toplx = (int) r.tl().x;
          }
          if ((r.tl().y > (toply-30)) && (r.tl().y < (toply+30))) {
          toply = (int) r.tl().y;
          }
          }
          }
          if (toply != 0) {
          org.opencv.core.Point tl = new org.opencv.core.Point(toplx, toply);
          org.opencv.core.Point br = new org.opencv.core.Point(toplx+175, toply+175);
          // Rectangle: image, top_left, bottom_right, color, thickness
          Core.rectangle(frame, tl, br, new Scalar(0, 255, 0), 2);
        }
        ImageIcon image = new ImageIcon(Mat2bufferedImage(frame));
        vidpanel.setIcon(image);
        vidpanel.repaint();
        }
        try {
        bw.close();
        } catch (Exception e) {
        System.out.println(e);
        }
        //System.out.println("Cannot read the video frames.");
        //System.exit(0);
      } else {
        // wait for something to be added to the queue
        TimeUnit.SECONDS.sleep(1);
      }
    }
  }

  public static BufferedImage Mat2bufferedImage(Mat image) {
    MatOfByte bytemat = new MatOfByte();
    Highgui.imencode(".jpg", image, bytemat);
    byte[] bytes = bytemat.toArray();
    InputStream in = new ByteArrayInputStream(bytes);
    BufferedImage img = null;
    try {
      img = ImageIO.read(in);
    } catch (IOException e) {
      e.printStackTrace();
    }
    return img;
  }

  public static Rect detect_mouse(Mat outmat) {
    Mat v = new Mat();
    List<MatOfPoint> contours = new ArrayList<MatOfPoint>();
    Imgproc.findContours(outmat, contours, v, Imgproc.RETR_LIST,
    Imgproc.CHAIN_APPROX_SIMPLE);

    Rect r = null;
    int tleftx = 10000000;
    int tlefty = 10000000;
    int brightx = 0;
    int brighty = 0;
    boolean ignore = false;

    for (int idx=1; idx<contours.size(); idx++) {
      r = Imgproc.boundingRect(contours.get(idx));
      if (r.tl().x < tleftx) {
        tleftx = (int) r.tl().x;
      }
      if (r.tl().y < tlefty) {
        tlefty = (int) r.tl().y;
      }
      if (r.br().x > brightx) {
        brightx = (int) r.br().x;
      }
      if (r.br().y > brighty) {
        brighty = (int) r.br().y;
      }
    }
    int width = brightx - tleftx;
    int height = brighty - tlefty;
    if ((width < 75) || (height < 75)) {
      ignore = true;
    } else {
      if (width != 175) {
        width = 175;
      }
      if (height != 175) {
        height = 175;
      }
    }
    if (ignore == false) {
      r = new Rect(tleftx, tlefty, width, height);
    } else {
      r = null;
    }
    v.release();
    return r;
  }
}
